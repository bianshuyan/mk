(define (var) (vector #f))
(define var? vector?)
(define (ext-d x v d)
  (if (occurs? x v d) #f (cons (cons x v) d)))
(define (occurs? x v d)
  (let ((v (walk v d)))
    (cond ((var? v) (eqv? x v))
          ((pair? v)
           (or (occurs? x (car v) d)
               (occurs? x (cdr v) d)))
          (else #f))))
(define (unify u v d)
  (let ((u (walk u d)) (v (walk v d)))
    (cond ((eqv? u v) d)
          ((var? u) (ext-d u v d))
          ((var? v) (ext-d v u d))
          ((and (pair? u) (pair? v))
           (let ((d (unify (car u) (car v) d)))
             (and d (unify (cdr u) (cdr v) d))))
          (else #f))))
(define (walk v d)
  (let ((a (and (var? v) (assv v d))))
    (if a (walk (cdr a) d) v)))
(define-syntax disj2
  (syntax-rules ()
    ((_ g1 g2) (lambda (s/c*) ($ppend (g1 s/c*) (g2 s/c*))))))
(define-syntax disj
  (syntax-rules ()
    ((_) fail)
    ((_ g) g)
    ((_ g0 g1 ...)
     (disj2 g0 (lambda (s/c*) (lambda () ((disj g1 ...) s/c*)))))))
(define-syntax conj2
  (syntax-rules ()
    ((_ g1 g2) (lambda (s/c*) ($ppend-map g2 (g1 s/c*))))))
(define-syntax conj
  (syntax-rules ()
    ((_) succeed)
    ((_ g) g)
    ((_ g0 g1 ...)
     (conj2 g0 (lambda (s/c*) (lambda () ((conj g1 ...) s/c*)))))))
(define ($ppend $1 $2)
  (cond ((null? $1) $2)
        ((pair? $1) (cons (car $1) ($ppend (cdr $1) $2)))
        (else (lambda () ($ppend $2 ($1))))))
(define ($ppend-map g $)
  (cond ((null? $) '())
        ((pair? $) ($ppend (g (car $)) ($ppend-map g (cdr $))))
        (else ($ppend-map g ($)))))
(define (succeed s/c*) (list s/c*))
(define (fail s/c*) '())
(define (=/= u v)
  (lambda (s/c*)
    (let ((s (car s/c*)))
      (let ((d (unify u v s)))
        (if d
            (if (eq? d s)
                '()
                (list (cons s (cons (prefix d s) (cdr s/c*)))))
            (list s/c*))))))
(define (== u v)
  (lambda (s/c*)
    (let ((d (unify u v (car s/c*))))
      (if d
          (if (eq? d (car s/c*))
              (list s/c*)
              (let ((c* (verify (cdr s/c*) d '())))
                (if c* (list (cons d c*)) '())))
          '()))))
(define (unify* p* d)
  (if (null? p*)
      d
      (let ((d (unify (caar p*) (cdar p*) d)))
        (and d (unify* (cdr p*) d)))))
(define (verify c* r nc*)
  (if (null? c*)
      nc*
      (let ((nc (unify* (car c*) r)))
        (if nc
            (if (eq? nc r)
                #f
                (verify (cdr c*) r (cons (prefix nc r) nc*)))
            (verify (cdr c*) r nc*)))))
(define (prefix x y)
  (if (eq? x y)
      '()
      (cons (car x) (prefix (cdr x) y))))
(define-syntax fresh
  (syntax-rules ()
    ((_ (x ...) g ...)
     (let ((x (var)) ...) (conj g ...)))))
(define (subsumed? c c*)
  (if (null? c*)
      #f
      (if (eq? (unify* c (car c*)) (car c*))
          #t
          (subsumed? c (cdr c*)))))
(define (simplify-c* c* nc*)
  (cond ((null? c*) nc*)
        ((or (subsumed? (car c*) (cdr c*)) (subsumed? (car c*) nc*))
         (simplify-c* (cdr c*) nc*))
        (else (simplify-c* (cdr c*) (cons (car c*) nc*)))))
(define (walk* v d)
  (let ((v (walk v d)))
    (if (pair? v)
        (cons (walk* (car v) d)
              (walk* (cdr v) d))
        v)))
(define (reify-d v r)
  (let ((v (walk v r)))
    (cond ((var? v)
           (let ((rn (reify-name (length r))))
             (cons (cons v rn) r)))
          ((pair? v)
           (let ((r (reify-d (car v) r)))
             (reify-d (cdr v) r)))
          (else r))))
(define (reify-name n)
  (string->symbol
   (string-append "_." (number->string n))))
(define (purify c* r)
  (cond ((null? c*) '())
        ((anyvar? (car c*) r) (purify (cdr c*) r))
        (else (cons (car c*) (purify (cdr c*) r)))))
(define (anyvar? c r)
  (cond ((var? c) (var? (walk c r)))
        ((pair? c) (or (anyvar? (car c) r) (anyvar? (cdr c) r)))
        (else #f)))
(define (reify v)
  (lambda (s/c*)
    (let ((v (walk* v (car s/c*)))
          (c* (walk* (cdr s/c*) (car s/c*))))
      (let ((r (reify-d v '())))
        (let ((v (walk* v r))
              (c* (walk* (simplify-c* (purify c* r) '()) r)))
          (if (null? c*)
              v
              (cons v (cons ':
                (map (lambda (c) (list '=/= (map car c) (map cdr c))) c*)))))))))
(define-syntax conde
  (syntax-rules ()
    ((_ (g ...) ...)
     (disj (conj g ...) ...))))
(define (take n $)
  (cond ((or (= n 0) (null? $)) '())
        ((pair? $)
         (cons (car $) (take (- n 1) (cdr $))))
        (else (take n ($)))))
(define-syntax run
  (syntax-rules ()
    ((_ n (x0 x1 ...) g ...)
     (run n q (fresh (x0 x1 ...)
                (== (list x0 x1 ...) q) g ...)))
    ((_ n q g ...)
     (let ((q (var)))
       (map (reify q) (take n ((conj g ...) '(()))))))))
(define-syntax defrel
  (syntax-rules ()
    ((_ (name x ...) g ...)
     (define (name x ...)
       (lambda (d)
         (lambda ()
           ((conj g ...) d)))))))
(define (take-all $)
  (cond ((null? $) '())
        ((pair? $) (cons (car $) (take-all (cdr $))))
        (else (take-all ($)))))
(define-syntax run*
  (syntax-rules ()
    ((_ (x0 x1 ...) g ...)
     (run* q (fresh (x0 x1 ...)
                (== (list x0 x1 ...) q) g ...)))
    ((_ q g ...)
     (let ((q (var)))
       (map (reify q) (take-all ((conj g ...) '(()))))))))
(define (succeed s/c*) (list s/c*))
(define (fail s/c*) '())
